" Name: jupytext.vim
" Last Change: Jan 1, 2019
" Author:  Michael Goerz <http://michaelgoerz.net>
" Plugin Website: https://github.com/goerz/jupytext.vim
" Summary: Vim plugin for editing Jupyter ipynb files via jupytext
" Version: 0.1.0-dev
" License:
"    MIT License
"
"    Copyright (c) 2019 Michael Goerz
"
"    Permission is hereby granted, free of charge, to any person obtaining a
"    copy of this software and associated documentation files (the
"    "Software"), to deal in the Software without restriction, including
"    without limitation the rights to use, copy, modify, merge, publish,
"    distribute, sublicense, and/or sell copies of the Software, and to permit
"    persons to whom the Software is furnished to do so, subject to the
"    following conditions:
"
"    The above copyright notice and this permission notice shall be included
"    in all copies or substantial portions of the Software.
"
"    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
"    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
"    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
"    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
"    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
"    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
"    USE OR OTHER DEALINGS IN THE SOFTWARE.
"
" Installation:
"    1. Copy the jupytext.vim script to your vim plugin directory (e.g.
"       $HOME/.vim/plugin).  Refer to ':help add-plugin', ':help
"       add-global-plugin' and ':help runtimepath' for more details about Vim
"       plugins.
"    2. Restart Vim.
"
" Usage:
"    When you open a Jupyter Notebook (*.ipynb) file, it is automatically
"    converted from json to markdown or python through the `jupytext` utility
"    (https://github.com/mwouts/jupytext), and the result is loaded into the
"    buffer. Upon saving, the ipynb file is updated with any modifications.
"
"    In more detail, opening a file notebook.ipynb in vim will create a
"    temporary file notebook.md or notebook.py (depending on g:jupytext_fmt).
"    This file is the result of calling e.g.
"
"       jupytext --to=md --output notebook.md notebook.ipynb
"
"    The contents of the file is loaded into the buffer instead of the
"    original notebook.ipynb. When saving the buffer, its contents is written
"    again to notebook.md, and the original notebook.ipynb is updated with
"    a call to
"
"       jupytext --to=ipynb --from=md --update --output notebook.ipynb notebook.md
"
"    The --update flag ensures the output for any cell whose corresponding
"    input in notebook.md is unchanged will be preserved.
"
"    On closing the buffer, the temporary notebook.md will be deleted. If
"    notebook.md already exist when opening notebook.ipynb, the existing file
"    will be used (instead of being generated by jupytext), and it will be
"    preserved when closing the buffer.
"
" Configuration:
"    The following settings in your ~/.vimrc may be used to configure the
"    plugin:
"
"    *  let g:jupytext_enable = 1
"
"       You may disable the automatic conversion of ipynb files (i.e.,
"       deactivate this plugin) by setting this to 0.
"
"    *  let g:jupytext_fmt = 'md'
"
"       One of 'md' or 'py'. The format to which to convert the ipynb data,
"       and extension of the linked text file.
"
"    *  let g:jupytext_filetype_map = {'md': 'markdown', 'py': 'python', }
"
"       A mapping of g:jupytext_fmt to the filetype that should be used for
"       the buffer (:help filetype). This determines the syntax highlighting.

if exists("loaded_jupytext") || &cp || exists("#BufReadCmd#*.ipynb")
    finish
endif


if !exists('g:jupytext_enable')
    let g:jupytext_enable = 1
endif

if !exists('g:jupytext_fmt')
    let g:jupytext_fmt = 'md'
endif

if !exists('g:jupytext_filetype_map')
    let g:jupytext_filetype_map = {
\      'md': 'markdown',
\      'py': 'python',
\   }
endif

if !g:jupytext_enable
    finish
endif
augroup ipynb
    " Remove all ipynb autocommands
    au!
    autocmd BufReadCmd *.ipynb  call s:read_from_ipynb(1)
    autocmd FileReadCmd *.ipynb call s:read_from_ipynb(0)
    autocmd BufWriteCmd,FileWriteCmd *.ipynb call s:write_to_ipynb()
augroup END


function s:read_from_ipynb(bufread)
    " The bufread argument specifies whether this was called due to BufReadCmd
    let filename = resolve(expand("<afile>:p"))
    let fileroot = fnamemodify(filename, ':r')
    if a:bufread
        let b:jupytext_file = fnameescape(fileroot) . "." . g:jupytext_fmt
        let b:jupytext_file_exists = filereadable(b:jupytext_file)
    else
        let b:jupytext_file = s:tmpfilename(fileroot, g:jupytext_fmt)
        let b:jupytext_file_exists = 0
    endif
    "echomsg "DBG: File exists:".b:jupytext_file_exists
    if (filereadable(l:filename) && !b:jupytext_file_exists)
        "echomsg "DBG: Generate file ".b:jupytext_file
        let l:cmd = "!jupytext --to=".g:jupytext_fmt
                    \ . " --output=".fnameescape(b:jupytext_file) . " "
                    \ . shellescape(filename)
        silent execute l:cmd
        if v:shell_error
            echoerr l:cmd.": ".v:shell_error
            return
        endif
    endif
    if filereadable(b:jupytext_file)
        silent execute "read" b:jupytext_file
    endif
    if a:bufread
        if b:jupytext_file_exists
            let l:register_unload_cmd = "autocmd BufUnload <buffer> call s:cleanup(\"".fnameescape(b:jupytext_file)."\", 0)"

        else
            let l:register_unload_cmd = "autocmd BufUnload <buffer> call s:cleanup(\"".fnameescape(b:jupytext_file)."\", 1)"
        endif
        "echomsg "DBG: ".l:register_unload_cmd
        silent execute l:register_unload_cmd
        let l:ft = get(g:jupytext_filetype_map, g:jupytext_fmt, g:jupytext_fmt)
        silent execute "set ft=".l:ft
        " In order to make :undo a no-op immediately after the buffer is read,
        " we need to do this dance with 'undolevels'.  Actually discarding the
        " undo history requires performing a change after setting 'undolevels'
        " to -1 and, luckily, we have one we need to do (delete the extra line
        " from the :r command)
        let levels = &undolevels
        set undolevels=-1
        silent 1delete
        let &undolevels = levels
        silent execute "autocmd BufEnter <buffer> redraw | echo fnamemodify(b:jupytext_file, ':.').' via jupytext.'"
    else
        " remove the temporary file
        call delete(expand(fnameescape(b:jupytext_file)))
    endif
endfunction


function s:tmpfilename(root, extension)
    let l:head = fnamemodify(a:root, ':h')
    let l:tail = fnamemodify(a:root, ':t')
    let i = 1
    let l:fname = l:head."/.".i."__".l:tail.".".a:extension
    while filereadable(fnameescape(l:fname))
        let i = i + 1
        let fname = l:head."/.".i."__".l:tail.".".a:extension
    endw
    "echomsg "DBG: tmpfilename: ".l:fname
    return l:fname
endfunction


function s:write_to_ipynb() abort
    let filename = resolve(expand("<afile>:p"))
    "echomsg "DBG: overwriting ".fnameescape(b:jupytext_file)
    execute "write! ".fnameescape(b:jupytext_file)
    "echomsg "DBG: Updating notebook from ".b:jupytext_file
    let l:cmd = "!jupytext --from=" . g:jupytext_fmt . " --update "
                \ . "--to=ipynb --output=".fnameescape(filename)." "
                \ . shellescape(b:jupytext_file)
    silent execute l:cmd
    if v:shell_error
        echoerr l:cmd.": ".v:shell_error
    else
        setlocal nomodified
    endif
endfunction


function s:cleanup(jupytext_file, delete)
    "echomsg "DBG: a:jupytext_file:".a:jupytext_file
    if a:delete
        "echomsg "DBG: deleting ".fnameescape(a:jupytext_file)
        call delete(expand(fnameescape(a:jupytext_file)))
    endif
endfunction


let loaded_jupytext = 1
